module quantum.gates;

/++
$(H2 Quantum Gates Module)

Standard quantum gates for quantum circuit simulation.

This module provides all common single-qubit, two-qubit, and three-qubit gates
used in quantum computing.

$(H3 Single-Qubit Gates)
$(UL
    $(LI Pauli gates: X, Y, Z)
    $(LI Hadamard: H)
    $(LI Phase gates: S, T, S†, T†)
    $(LI Rotation gates: Rx(θ), Ry(θ), Rz(θ))
)

$(H3 Multi-Qubit Gates)
$(UL
    $(LI CNOT/CX: Controlled-NOT)
    $(LI CY, CZ: Controlled-Y, Controlled-Z)
    $(LI SWAP: Swap two qubits)






























































































































































































































































}    }        ];            [C(0.5L, 0.5L), C(0.5L, 0.5L)]            [C(0.5L, 0.5L), C(-0.5L, -0.5L)],        return [    static C[2][2] SqrtY() {    +/    √Y gate (square root of Y).    /++    }        ];            [C(0.5L, -0.5L), C(0.5L, 0.5L)]            [C(0.5L, 0.5L), C(0.5L, -0.5L)],        return [    static C[2][2] SqrtX() {    +/    Matrix: (1+i)/2 * [1 -i; -i 1] (up to global phase)        Applying twice gives X gate.        √X gate (square root of X).    /++    // =========================================================================    // SQRT GATES    // =========================================================================    ];        [C(0), C(1)]        [C(1), C(0)],    static immutable C[2][2] I = [    +/    Matrix: [1 0; 0 1]        Identity gate (no operation).    /++    // =========================================================================    // IDENTITY    // =========================================================================    }        ];            [C(0), C(cos(phi), sin(phi))]            [C(1), C(0)],        return [    static C[2][2] P(real phi) {    +/        phi = Phase angle in radians    Params:        Note: S = P(π/2), T = P(π/4), Z = P(π)        Matrix: [1 0; 0 e^(iφ)]        P(φ)|0⟩ = |0⟩, P(φ)|1⟩ = e^(iφ)|1⟩        General phase gate P(φ).    /++    }        ];            [C(0), C(c, s)]            [C(c, -s), C(0)],        return [        real s = sin(theta / 2.0L);        real c = cos(theta / 2.0L);    static C[2][2] Rz(real theta) {    +/        theta = Rotation angle in radians    Params:        Matrix: [e^(-iθ/2) 0; 0 e^(iθ/2)]        Rz(θ) = e^(-iθ/2)|0⟩⟨0| + e^(iθ/2)|1⟩⟨1|        Rz gate - rotation around Z-axis by angle θ.    /++    }        ];            [C(s), C(c)]            [C(c), C(-s)],        return [        real s = sin(theta / 2.0L);        real c = cos(theta / 2.0L);    static C[2][2] Ry(real theta) {    +/        theta = Rotation angle in radians    Params:        Matrix: [cos(θ/2) -sin(θ/2); sin(θ/2) cos(θ/2)]        Ry(θ) = cos(θ/2)I - i·sin(θ/2)Y        Ry gate - rotation around Y-axis by angle θ.    /++    }        ];            [C(0, -s), C(c)]            [C(c), C(0, -s)],        return [        real s = sin(theta / 2.0L);        real c = cos(theta / 2.0L);    static C[2][2] Rx(real theta) {    +/        theta = Rotation angle in radians    Params:        Matrix: [cos(θ/2) -i·sin(θ/2); -i·sin(θ/2) cos(θ/2)]        Rx(θ) = cos(θ/2)I - i·sin(θ/2)X        Rx gate - rotation around X-axis by angle θ.    /++    // =========================================================================    // ROTATION GATES    // =========================================================================    }        ];            [C(0), C(cos(angle), sin(angle))]            [C(1), C(0)],        return [        immutable real angle = -PI / 4.0L;    static C[2][2] Tdag() {    +/    Matrix: [1 0; 0 e^(-iπ/4)]        T† gate (T-dagger, inverse of T).    /++    }        ];            [C(0), C(cos(angle), sin(angle))]            [C(1), C(0)],        return [        immutable real angle = PI / 4.0L;    static C[2][2] T() {    +/    Matrix: [1 0; 0 e^(iπ/4)]        T|0⟩ = |0⟩, T|1⟩ = e^(iπ/4)|1⟩        T gate (√S gate, π/8 gate).    /++    ];        [C(0), C(0, -1)]        [C(1), C(0)],    static immutable C[2][2] Sdag = [    +/    Matrix: [1 0; 0 -i]        S† gate (S-dagger, inverse of S).    /++    ];        [C(0), C(0, 1)]        [C(1), C(0)],    static immutable C[2][2] S = [    +/    Matrix: [1 0; 0 i]        S|0⟩ = |0⟩, S|1⟩ = i|1⟩        S gate (√Z gate, phase gate).    /++    // =========================================================================    // PHASE GATES    // =========================================================================    ];        [C(SQRT2_INV), C(-SQRT2_INV)]        [C(SQRT2_INV), C(SQRT2_INV)],    static immutable C[2][2] H = [    +/    Matrix: [1 1; 1 -1] / √2        H|1⟩ = (|0⟩ - |1⟩)/√2    H|0⟩ = (|0⟩ + |1⟩)/√2        Hadamard gate - creates superposition.    /++    // =========================================================================    // HADAMARD GATE    // =========================================================================    ];        [C(0), C(-1)]        [C(1), C(0)],    static immutable C[2][2] Z = [    +/    Matrix: [1 0; 0 -1]        Z|0⟩ = |0⟩, Z|1⟩ = -|1⟩        Pauli-Z gate (phase-flip).    /++    ];        [C(0, 1), C(0)]        [C(0), C(0, -1)],    static immutable C[2][2] Y = [    +/    Matrix: [0 -i; i 0]        Y|0⟩ = i|1⟩, Y|1⟩ = -i|0⟩        Pauli-Y gate.    /++    ];        [C(1), C(0)]        [C(0), C(1)],    static immutable C[2][2] X = [    +/    Matrix: [0 1; 1 0]        X|0⟩ = |1⟩, X|1⟩ = |0⟩        Pauli-X gate (NOT gate / bit-flip).    /++    // =========================================================================    // PAULI GATES    // =========================================================================    private static immutable real SQRT2_INV = 1.0L / sqrt(2.0L);    /// 1/√2 constant used in many gatesstruct Gates {/// Collection of standard quantum gates as 2x2 unitary matricesimport std.math : sqrt, cos, sin, PI;import quantum.common : C;module quantum.gates;+/---reg.applyGate(0, Gates.Rx(PI/4)); // Rotation around Xreg.applyGate(1, Gates.T);       // T gate on qubit 1reg.applyGate(0, Gates.H);       // Hadamard on qubit 0auto reg = QRegister!2([C(1), C(0), C(0), C(0)]);---Example:)    $(LI Toffoli/CCNOT: Controlled-controlled-NOT)
    $(LI Fredkin/CSWAP: Controlled-SWAP)